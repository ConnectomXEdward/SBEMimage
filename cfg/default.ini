# Default user/project configuration file, used as a template to validate all other user/project configuration files 
# SBEMimage version 2.0
#
# DO NOT EDIT this file unless you know what you are doing!
# Comments refer to the key in the following line, with the format: explanation of the key; object in SBEMimage that manages it

[sys]
# system configuration file associated with this user/project configuration file; main_controls (read only)
sys_config_file = system.cfg
# True if simulation mode active (no connection to SEM/microtome); main_controls
simulation_mode = True
# True if microtome to be used; main_controls 
use_microtome = True
# mirror drive (for mirroring acquired data, must be a drive letter [X:], can point to a network drive); stack_acquisition
mirror_drive = Z:
# True if mirror drive to be used; stack_acquisition
use_mirror_drive = False
# True if plasma cleaner ('plc'; = downstream asher) installed; main_controls (read only)
plc_installed = False
# serial port used by plasma cleaner; main_controls (read only), launches plasma_cleaner
plc_com_port = COM5
# email account used for remote monitoring and commands (password is provided by user at runtime, not stored anywhere); stack_acquisition (read only)
email_account = account_name@server.ch
# SMTP server for the email account above; stack_acquisition (read only)
email_smtp = smtp.server.ch
# IMAP server for the email account above; stack_acquisition (read only)
email_imap = imap.server.ch
# URL of the server to which metadata is being sent while an acquisition is running (for example, VIME Server); stack_acquisition
metadata_server_url = https://remote.server.ch
# email of the administrator of the metadata server (for alerts and remote control); stack_acquisition
metadata_server_admin = account_name@server.ch
# name of the project (for metadata server [VIME]);
metadata_project_name = test
# True if metadata to be send to metadata server during acquisition; stack_acquisition
send_metadata = False
# True if MagC mode (wafer acquisition mode) active; main_controls
magc_mode = False

[sem]
# name of the SEM: sem_control
device = ZEISS Merlin
# target EHT (= high voltage) in kV; sem_control
eht = 1.5
# target beam current in pA; sem_control
beam_current = 300.0
# default dwell time for single frames in microseconds; sem_control
grab_frame_dwell_time = 0.8
# default pixel size for single frames in nanometre; sem_control
grab_frame_pixel_size = 10.0
# default frame size selector for single frames; sem_control
grab_frame_size_selector = 4
# default frame size in pixels for single frames (set according to grab_frame_size_selector); sem_control
grab_frame_size_xy = [4096, 3072]
# True if auto beam blank active; sem_control
auto_beam_blank = True
# BSE detector contrast setting; sem_control
bsd_contrast = 5.2
# BSE detector brightness setting; sem_control
bsd_brightness = 0.9
# BSE detector bias voltage; sem_control
bsd_bias = -6
# speed of X motor in microns/second; sem_control 
motor_speed_x = 1000
# speed of Y motor in microns/second; sem_control
motor_speed_y = 1000
# waiting time in seconds after each stage move before acquiring new image; sem_control
stage_move_wait_interval = 1.5
# X motor range minimum value in micrometres; sem_control
stage_min_x = 0
# X motor range maximum value in micrometres; sem_control
stage_max_x = 130000
# Y motor range minimum value in micrometres; sem_control
stage_min_y = 0
# Y motor range maximum value in micrometres; sem_control
stage_max_y = 130000
# calibration scale factor for X axis; coordinate_system
stage_scale_factor_x = 1.0
# calibration scale factor for Y axis; coordinate_system
stage_scale_factor_y = 1.0
# calibration: rotation angle for X axis; coordinate_system
stage_rotation_angle_x = 0.0
# calibration: rotation angle for Y axis; coordinate_system
stage_rotation_angle_y = 0.0

[microtome]
device = Gatan 3View
knife_cut_speed = 300
knife_fast_speed = 1500
knife_retract_speed = 900
knife_cut_start = 1500
knife_cut_end = 0
knife_oscillation = True
knife_osc_amplitude = 100
knife_osc_frequency = 25000
full_cut_duration = 16
sweep_distance = 70
motor_speed_x = 62.5
motor_speed_y = 52.63
stage_move_wait_interval = 1.5
stage_min_x = -1150
stage_max_x = 1080
stage_min_y = -895
stage_max_y = 845
stage_scale_factor_x = 0.9341
stage_scale_factor_y = 0.9469
stage_rotation_angle_x = 0.7288
stage_rotation_angle_y = 0.6534
last_known_z = None

[acq]
# base directory of the current acquisition; stack_acquisition
base_dir = C:\temp\sbemimage_test
# target number of slices to be acquired; stack_acquisition
number_slices = 1000
# slice counter = current slice index; stack_acquisition
slice_counter = 0
# thick thickness in nanometres; stack_acquisition
slice_thickness = 50
# total Z depth of sample removed by microtome, in micrometres; stack_acquisition
total_z_diff = 0.0
# True if acquisition paused; stack_acquisition
paused = False
# True if acquisition interrupted; stack_acquisition
interrupted = False
# Position of interruption [grid_index, tile_index]; stack_acquisition
interrupted_at = []
# Tiles already acquired (in grid where interruption occured) before the interruption occured; stack_acquisition
tiles_acquired = []
# Grids already (completely) acquired before interruption occured; stack_acquisition
grids_acquired = []
# True if overviews to be acquired during stack acquisition; stack_acquisition
take_overviews = True
# True if images to be monitored (threshold tests); stack_acquisition
monitor_images = False
# True if email monitoring to be used; stack_acquisition
use_email_monitoring = False
# True if autofocus to be used; stack_acquisition
use_autofocus = False
# True if debris detection and removal to be used; stack_acquisition
use_debris_detection = True
# True if 'Ask User Mode' active; stack_acquisition
ask_user = False
# Truef if EHT (= high voltage) to be switched off after stack is completed; stack_acquisition
eht_off_after_stack = False

[grids]
number_grids = 1
grid_active = [1]
origin_sx_sy = [[-20.094580670938154, -21.577466750269956]]
rotation = [0]
size = [[4, 4]]
overlap = [200]
row_shift = [0]
active_tiles = [[6, 5, 9, 10]]
tile_size = [[4096, 3072]]
tile_size_selector = [4]
pixel_size = [10.0]
dwell_time = [0.8]
dwell_time_selector = [4]
display_colour = [0]
acq_interval = [1]
acq_interval_offset = [0]
wd_stig_xy = [[0, 0, 0]]
use_wd_gradient = [0]
wd_gradient_ref_tiles = [[-1, -1, -1]]
wd_gradient_params = [[0, 0]]
wd_stig_params = {}

[overviews]
number_ov = 1
ov_active = [1]
ov_centre_sx_sy = [[0.6984196553220267, 2.999938272673049]]
ov_rotation = [0]
ov_size = [[2048, 1536]]
ov_size_selector = [2]
ov_pixel_size = [155.0]
ov_dwell_time = [0.8]
ov_dwell_time_selector = [4]
ov_wd_stig_xy = [[0, 0, 0]]
ov_acq_interval = [1]
ov_acq_interval_offset = [0]
ov_viewport_images = [""]
stub_ov_centre_sx_sy = [0, 0]
stub_ov_grid_size_selector = 2
stub_ov_overlap = 32
stub_ov_frame_size_selector = 0
stub_ov_pixel_size = 372
stub_ov_dwell_time_selector = 4
stub_ov_viewport_image =

[imported] 
number_imported = 0
image_src = []
description = []
centre_sx_sy = []
rotation = []
size = []
pixel_size = []
transparency = []

[viewport]
vp_centre_dx_dy = [-56.15046054879757, -2.46444871774041]
vp_scale = 0.23152500000000004
vp_current_grid = -1
vp_current_ov = -1
vp_tile_preview_mode = 0
show_stub_ov = False
show_imported = False
show_axes = True
show_labels = True
show_native_resolution = True
show_saturated_pixels = False
sv_current_grid = 0
sv_current_tile = 1
sv_current_ov = -1
sv_scale_tile = 100.0
sv_scale_ov = 6.437913785074596
sv_offset_x_tile = -2147
sv_offset_y_tile = -1595
sv_offset_x_ov = -484
sv_offset_y_ov = -335
m_current_grid = 0
m_current_tile = -1
m_current_ov = -1

[monitoring]
# primary email address for monitoring (status reports and error notifications); notifications
user_email = primary_user@server.ch
# secondary (optional) email address for monitoring; notifications
cc_user_email =
# slice interval for sending status report; stack_acquisition
report_interval = 100
# List of overviews to be sent in status report; notifications
report_ov_list = [0]
# List of tiles to be sent in status report; notifications
report_tile_list = [""]
# Line number limit of log in Main Controls windows (most recent lines); main_controls (read only)
max_log_line_count = 2000
# True if main log to be sent in status report; notifications
send_logfile = True
# True if debris and error logs to be sent in status report; notifications
send_additional_logs = True
# True if viewport screenshot to be sent in status report; notifications
send_viewport_screenshot = True
# True if overview(s) in report_ov_list to be sent in status report; notifications
send_ov = True
# True if tiles in report_tile_list to be sent in status report; notifications
send_tiles = False
# True if reslices of overviews in report_ov_list to be sent in status report; notifications
send_ov_reslices = False
# True if reslices of tiles in report_tile_list to be sent in status report; notifications
send_tile_reslices = False
# True if remote commands (sent by user via email to SBEMimage) are enabled; notifications
remote_commands_enabled = False
# slice interval for checking for remote commands; stack_acquisition
remote_check_interval = 10
mean_lower_limit = 79
mean_upper_limit = 193
stddev_lower_limit = 10
stddev_upper_limit = 103
monitor_tiles = [""]
tile_mean_threshold = 1.0
tile_stddev_threshold = 0.5

[debris]
detection_method = 0
detection_area = [[934, 816, 1449, 1200]]
show_detection_area = True
use_two_previous = False
min_quadrant_area = 80000
mean_diff_threshold = 3.0
stddev_diff_threshold = 1.0
image_diff_threshold = 600
median_filter_kernel_size = 7
image_diff_hist_lower_limit = 30
histogram_diff_threshold = 30000
auto_detection_area = True
auto_area_margin = 20
# maximum number of sweep if debris is detected; stack_acquisition
max_number_sweeps = 3
# True if acquisition automatically continues after max_number_sweeps reached; stack_acquisition
continue_after_max_sweeps = False

[autofocus]
method = 0
ref_tiles = ["0.0"]
tracking_mode = 0
max_wd_stig_diff = [1e-05, 1.0, 1.0]
interval = 50
autostig_delay = 5
pixel_size = 5.0
heuristic_deltas = [8e-07, 0.05, 0.05]
heuristic_calibration = [0.05, 0.2, 0.2]
heuristic_rot_scale = [0.7, 1.0]

[magc]
sections_path = ""
roi_mode = True
wafer_calibrated = False
sections = {}
selected_sections = []
checked_sections = []
landmarks = {} 
wafer_transform = []